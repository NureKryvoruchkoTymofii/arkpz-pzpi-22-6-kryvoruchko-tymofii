МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
     
     
Кафедра «Програмної інженерії»
     
     
ЗВІТ
до лабораторної роботи №3
з дисципліни «Аналіз та рефакторинг коду»
на тему: «РОЗРОБКА БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ АДМІНІСТРУВАННЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ.»
     
     
     
     
     
Виконав:	            Перевірив:
ст. гр. ПЗПІ-22-6	    ст. виклад. каф. ПІ
Криворучко Т. О.	    Сокорчук І.П.
     
     
     
 
     
     

Харків 2024 
1 РОЗРОБКА БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ АДМІНІСТРУВАННЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ
1.1 Мета роботи:
Розробити бізнес логіку та функції адміністрування серверної частини програмної системи.
1.2.1 Хід роботи
1.2.1	Розробити бізнес логіку серверної частини програмної системи. 
1)  Генерація звітів про використання замків
Система генерує підсумковий звіт про кількість користувачів, адміністраторів, звичайних користувачів і замків, використовуючи дані з бази даних. Вона обчислює загальну кількість користувачів, кількість адміністраторів, а також кількість звичайних користувачів та замків, і повертає ці дані у вигляді звіту.
Алгоритм роботи наступний: 
1.	Отримує дані про кількість адміністраторів.
2.	Отримує дані про кількість користувачів.
3.	Отримує дані про кількість замків.
4.	Обчислює кількість звичайних користувачів (загальна кількість користувачів мінус адміністратори).
5.	Формує звіт з підсумковими даними.
6.	Повертає результат у вигляді повідомлення з даними або якщо присутні помилки.
2) Звіт користувача про доступ до замків
Система генерує звіт для користувача, який містить інформацію про доступ до замків, які він використовував, включаючи дані про замки та сенсори, що з ними пов'язані. Це дозволяє користувачеві отримати детальну інформацію про свій доступ до замків та їх поточний стан.
Алгоритм роботи наступний:
1.	Перевіряє, чи має користувач роль «user». Якщо ні, повертає помилку доступу.
2.	Отримує журнали доступу для поточного користувача, де була зафіксована дія «access_granted».
3.	Для кожного запису в журналах доступу отримує дані про замок, до якого було надано доступ.
4.	Отримує дані про сенсори, пов'язані з кожним замком, і формує інформацію про кожен сенсор (ID, локація, статус, тип).
5.	Формує звіт з даними про замки та сенсори.
6.	Повертає звіт користувачу або повідомлення про помилку у разі виникнення проблем.
3) Звіт про активність замка
Система генерує звіт про використання замка, аналізуючи дані з журналу використання. Звіт включає кількість використань замка, пікову годину активності та середній час між подіями (відкриттям і закриттям).
Алгоритм роботи:
1.	Отримує журнали використання замка за його ідентифікатором lockID.
2.	Якщо журнали відсутні, повертає помилку з повідомленням про відсутність активності.
3.	Обчислює загальну кількість разів, коли замок був відкритий або закритий.
4.	Аналізує активність замка за годинами, обчислюючи кількість подій для кожної години.
5.	Визначає годину з найбільшою активністю.
6.	Розраховує середній час між подіями (в секундах).
7.	Формує звіт з деталями використання замка, включаючи кількість використань, пікову годину і середній час між подіями.
8.	Повертає звіт або повідомлення про помилку.
4) Автоматичне закриття замка
Система автоматично змінює стан замка на "закритий", якщо він зараз відкритий. Вона здійснює перевірку стану замка і при необхідності змінює його на "locked".
Алгоритм роботи:
1.	Отримує дані з запиту (ID замка).
2.	Перевіряє, чи існує замок з вказаним ID.
3.	Якщо замок не знайдений, повертає помилку.
4.	Якщо замок відкритий (статус "unlocked"), змінює його статус на "locked" і зберігає зміни.
5.	Записує подію в журнал.
6.	Повертає повідомлення про успішне автоматичне закриття замка, якщо це було здійснено.
7.	Якщо замок вже закритий, повертається повідомлення, що замок уже закритий.
5) Оновлення часу автоматичного закриття замка
Система дозволяє оновити параметр часу автоматичного закриття замка. Вона перевіряє правильність введених даних та зберігає новий час для замка.
Алгоритм роботи:
1.	Отримує дані з запиту (ID замка та новий час для автоматичного закриття).
2.	Перевіряє, чи є вхідні дані і чи є вони коректними (ID замка та дійсне число для часу).
3.	Якщо дані некоректні, повертає помилку.
4.	Перевіряє, чи існує замок з вказаним ID.
5.	Якщо замок не знайдений, повертає помилку.
6.	Оновлює час автоматичного закриття замка.
7.	Зберігає зміни і повертає повідомлення про успішне оновлення часу автоматичного закриття замка, а також сам замок з оновленими даними.

1.2.2	 Розробити функції адміністрування серверної частини програмної системи.
1) Звіт адміністратора про дані сенсорів
Система генерує звіт для адміністратора, що містить дані про сенсори, встановлені на замках, до яких був наданий доступ користувачам. Звіт включає деталі про сенсори та їхні дані (тип, значення, час оновлення), що дозволяє адміністраторам здійснювати моніторинг стану сенсорів.
Алгоритм роботи:
1.	Перевіряє, чи має користувач роль «admin». Якщо ні, повертає помилку доступу.
2.	Отримує ідентифікатори замків, до яких був наданий доступ користувачу з журналів доступу.
3.	Отримує дані про замки, зокрема, сенсори, що належать цим замкам, і їхні дані.
4.	Якщо замки не знайдені, повертає порожній звіт.
5.	Формує звіт, що включає дані про замки, сенсори та їхні дані (ID, локація, статус, тип, значення та час).
6.	Повертає звіт адміністратора або повідомлення про помилку у разі виникнення проблем.
2) Аналіз даних сенсора
Система генерує звіт для адміністратора, що включає аналіз даних сенсора за вказаний період часу. Звіт містить середні значення, мінімальні та максимальні показники для кожного типу даних, а також виявлені аномалії.
Алгоритм роботи:
1.	Перевіряє, чи має користувач роль «admin». Якщо ні, повертається помилка доступу.
2.	Отримує дані сенсора за вказаний період часу (startDate до endDate).
3.	Якщо дані відсутні, записує помилку у лог і повертає повідомлення про відсутність даних.
4.	Групує отримані дані за типом даних (DataType).
5.	Для кожної групи обчислює середнє значення, мінімальне і максимальне значення.
6.	Визначає аномалії, якщо значення значно відрізняються від середнього (на основі порогу).
7.	Формує звіт, що включає ці показники і виявлені аномалії.
8.	Повертає звіт разом з рекомендацією для адміністратора по аналізу аномалій.
3) Додавання доступу користувача до замка
Система дозволяє адміністратору додавати запис про доступ користувача до замка, зберігаючи дані про користувача, замок і дію, яку було виконано.
Алгоритм роботи:
1.	Перевіряє, чи користувач має роль адміністратора.
2.	Якщо користувач не є адміністратором, повертає помилку доступу.
3.	Отримує дані з запиту (UserID, LockID та Action).
4.	Перевіряє, чи всі необхідні поля присутні у запиті. Якщо яке-небудь поле відсутнє, повертається помилка.
5.	Створює новий запис у таблиці AccessLog з отриманими даними.
6.	Зберігає новий запис у базі даних.
7.	Повертає повідомлення про успішне додавання доступу з кодом 201.
4) Експорт даних про замки та сенсори
Система дозволяє адміністратору експортувати дані про замки та їх сенсори у форматі CSV.
Алгоритм роботи:
1.	Перевіряється, чи є користувач адміністратором.
2.	Якщо користувач не є адміністратором, повертається помилка доступу.
3.	Отримуються всі замки, до яких адміністратор має доступ, на основі записів в таблиці AccessLog.
4.	Для кожного замка отримуються відповідні сенсори та їх дані з таблиці SensorData.
5.	Формується масив даних для експорту, включаючи інформацію про замки, сенсори та їх показники.
6.	Якщо дані відсутні, повертається помилка.
7.	Створюється директорія для збереження файлів, якщо вона не існує.
8.	Генерується CSV файл і записується у вказану директорію.
9.	Повертається повідомлення про успішний експорт з посиланням на файл.
5) Імпорт даних про замки та сенсори з CSV файлу
Функція дозволяє адміністратору імпортувати дані про замки, сенсори та їх дані із CSV файлу.
Алгоритм роботи:
1.	Перевіряється, чи файл був завантажений і чи немає помилки при завантаженні.
2.	Якщо файл не завантажений або є помилка, повертається помилка.
3.	Перевіряється, чи має файл розширення .csv.
4.	Якщо файл не є CSV, повертається помилка.
5.	Відкривається файл для читання.
6.	Зчитуються заголовки з першого рядка CSV файлу.
7.	Прочитуються всі рядки з файла і створюється масив імпортованих даних.
8.	Якщо все пройшло успішно, повертається повідомлення про успішний імпорт.

1.2.3	Створити програмну реалізацію
1) Для бізнес логіки було створено функцію, яка створює звіт про активність замка та також надає рекомендацію. Код функції знаходиться в додатку А.
2) Для адміністрування серверної частини, було створено функцію експорту даних. Код реалізації знаходиться в додатку В.

1.2.4	Перевірити роботу серверної частини системи.
Перевіримо експорт даних, використовуючи Postman.
 


 


Тепер протестуємо активність, використовуючи Postman: 
 

1.5 Посилання
Посилання на репозиторій: https://github.com/NureKryvoruchkoTymofii/arkpz-pzpi-22-6-kryvoruchko-tymofii/tree/main/Task3
Посилання на відео-доповідь: https://www.youtube.com/watch?v=gzOHcP0Y3fg
Посилання на UML діаграма діяльності для серверної частини;
Посилання на UML діаграма взаємодії для серверної частини.

 
Додаток А
1 public function lockActivityReport($lockID) {
  2         $logs = LockUsageLog::where('LockID', $lockID)->orderBy('Timestamp', 'asc')->get();
  3     
  4         if ($logs->isEmpty()) {
  5             return jsonResponse(['error' => 'No activity found for this lock'], 404);
  6         }
  7
  8         $usageCount = $logs->count();
  9
 10         // Аналіз активності по годинах
 11         $hourlyActivity = array_fill(0, 24, 0);
 12         foreach ($logs as $log) {
 13             $hour = (int)date('H', strtotime($log->Timestamp));
 14             $hourlyActivity[$hour]++;
 15         }
 16         $peakHour = array_search(max($hourlyActivity), $hourlyActivity);
 17
 18         // Розрахунок середнього часу між подіями
 19         $intervals = [];
 20         $lastOpenTime = null;
 21
 22         foreach ($logs as $log) {
 23             if ($log->Action === 'open') {
 24                 $lastOpenTime = strtotime($log->Timestamp);
 25             } elseif ($log->Action === 'close' && $lastOpenTime) {
 26                 $intervals[] = strtotime($log->Timestamp) - $lastOpenTime;
 27                 $lastOpenTime = null;
 28             }
 29         }
 30
 31         $averageInterval = $intervals ? array_sum($intervals) / count($intervals) : 0;
 32
 33         return jsonResponse([
 34             'LockID' => $lockID,
 35             'usageCount' => $usageCount,
 36             'peakHour' => $peakHour,
 37             'averageIntervalSeconds' => round($averageInterval, 2),
 38             'message' => 'Звіт про активність надає огляд використання замка.',
 39             'details' => [
 40                 'usageCount' => 'Загальна кількість разів, коли замок був відкритий або закритий.',
 41                 'peakHour' => 'Година, коли замок мав найбільшу активність. Це може допомогти визначити години пік використання.',     
 42                 'averageIntervalSeconds' => 'Середній час (в секундах) між відкриттям і закриттям замка. Це може допомогти зрозуміти поведінку користувачів і ефективність використання.'
 43             ]
 44         ], 200);
 45     }
 
Додаток B
1 public function exportData() {
  2         try {
  3             $user = $_SESSION['user'];
  4     
  5             // Перевірка, чи користувач є адміністратором
  6             if ($user['Role'] !== 'admin') {
  7                 return jsonResponse(['error' => 'Access denied: only admins can export data'], 403);
  8             }
  9     
 10             // Отримання всіх замків, до яких адміністратор має доступ
 11             $accessLogs = AccessLog::where('UserID', $user['UserID'])
 12                 ->where('Action', 'access_granted')
 13                 ->get();
 14     
 15             $csvData = [];
 16     
 17             // Для кожного доступного замка
 18             foreach ($accessLogs as $access) {
 19                 $lock = Lock::find($access->LockID);
 20                 if ($lock) {
 21                     // Отримуємо всі сенсори для поточного замка
 22                     $sensors = Sensor::where('LockID', $lock->LockID)->get();
 23                     foreach ($sensors as $sensor) {
 24                         // Отримуємо всі записи даних для кожного сенсора
 25                         $sensorDataEntries = SensorData::where('SensorID', $sensor->SensorID)->get();
 26                         foreach ($sensorDataEntries as $data) {
 27                             $csvData[] = [
 28                                 'LockID' => $lock->LockID,
 29                                 'LockName' => $lock->LockName,
 30                                 'LockLocation' => $lock->Location,
 31                                 'LockStatus' => $lock->Status,
 32                                 'LockCreatedAt' => $lock->CreatedAt,
 33                                 'LockOwnerID' => $lock->OwnerID,
 34                                 'AutoLockTime' => $lock->auto_lock_time,
 35                                 'SensorID' => $sensor->SensorID,
 36                                 'SensorLocation' => $sensor->Location,
 37                                 'SensorStatus' => $sensor->Status,
 38                                 'SensorLastUpdated' => $sensor->LastUpdated,
 39                                 'SensorType' => $sensor->SensorType,
 40                                 'DataID' => $data->DataID,
 41                                 'DataType' => $data->DataType,
 42                                 'DataValue' => $data->DataValue,
 43                                 'DataTimestamp' => $data->Timestamp,
 44                             ];
 45                         }
 46                     }
 47                 }
 48             }
 49
 50             if (empty($csvData)) {
 51                 return jsonResponse(['error' => 'No data available for export'], 404);
 52             }
 53
 54             $exportDir = __DIR__ . '/../../exports/';
 55             if (!file_exists($exportDir)) {
 56                 mkdir($exportDir, 0777, true);  // Створюємо директорію, якщо її немає
 57             }
 58
 59             // Створення CSV файлу
 60             $filename = 'export_data_' . date('Ymd_His') . '.csv';
 61             $filePath = __DIR__ . '/../../exports/' . $filename;
 62             $file = fopen($filePath, 'w');
 63
 64             // Заголовки CSV
 65             fputcsv($file, [
 66                 'LockID', 'LockName', 'LockLocation', 'LockStatus', 'LockCreatedAt',
 67                 'LockOwnerID', 'AutoLockTime', 'SensorID', 'SensorLocation', 'SensorStatus',
 68                 'SensorLastUpdated', 'SensorType', 'DataID', 'DataType', 'DataValue', 'DataTimestamp'
 69             ]);
 70
 71             // Запис даних у CSV
 72             foreach ($csvData as $row) {
 73                 fputcsv($file, $row);
 74             }
 75
 76             fclose($file);
 77
 78             // Повернення посилання на файл
 79             return jsonResponse([
 80                 'message' => 'Data exported successfully.',
 81                 'fileUrl' => "/exports/$filename",
 82             ], 200);
 83
 84         } catch (Exception $e) {
 85             return jsonResponse(['error' => 'Failed to export data: ' . $e->getMessage()], 500);
 86         }
 87     }
